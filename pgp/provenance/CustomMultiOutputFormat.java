/*
Copyright 2014 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package com.custom;

import org.apache.hadoop.fs.FSDataOutputStream;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.BytesWritable;
import org.apache.hadoop.io.NullWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.io.compress.CompressionCodec;
import org.apache.hadoop.io.compress.GzipCodec;
import org.apache.hadoop.mapred.*;
import org.apache.hadoop.mapred.lib.MultipleTextOutputFormat;
import org.apache.hadoop.util.*;

import java.io.DataOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;

/**
 * CustomMultiOutputFormat implements the VCF header for PGP CGI
 * data converted to VCF.
 *
 * It has the VCF header information generated by the prior run of
 * cgatools mkvcf.  It also works in conjuction with the mapper script
 * to consume the Map key as both the subdirectory in which the output
 * file should reside and also as a value in one of the VCF header
 * lines.
 *
 * The code that follows is a mashup of
 * http://stackoverflow.com/questions/18541503/multiple-output-files-for-hadoop-streaming-with-python-mapper
 * and a modified version of
 * org.apache.hadoop.mapred.TextOutputFormat.
 **/

public class CustomMultiOutputFormat<K, V> extends MultipleTextOutputFormat<K, V> {

  static final String DATASET_HEADER =
      "##fileformat=VCFv4.1\n"
      + "##fileDate=20140428\n"
      + "##center=Complete Genomics\n"
      + "##source=CGAPipeline_2.0.3.2;cgatools_1.8.0\n"
      + "##source_GENOME_REFERENCE=NCBI build 37\n"
      + "##source_GENE_ANNOTATIONS=NCBI build 37.2\n"
      + "##source_DBSNP_BUILD=dbSNP build 132\n"
      + "##source_COSMIC=COSMIC v48\n"
      + "##source_DGV_VERSION=9\n"
      + "##source_MIRBASE_VERSION=miRBase version 16\n"
      + "##source_PFAM_DATE=April 21, 2011\n"
      + "##source_REPMASK_GENERATED_AT=2011-Feb-15 10:08\n"
      + "##source_SEGDUP_GENERATED_AT=2010-Dec-01 13:40\n"
      + "##phasing=partial\n"
      + "##source_MAX_PLOIDY=10\n"
      + "##source_NUMBER_LEVELS=GS01173-DNA_H05:5\n"
      + "##source_NONDIPLOID_WINDOW_WIDTH=100000\n"
      + "##source_MEAN_GC_CORRECTED_CVG=GS01173-DNA_H05:86.59\n"
      + "##source_MEI_1000G_ANNOTATIONS=INITIAL-DATA-RELEASE\n"
      + "##reference=ftp://ftp.completegenomics.com/ReferenceFiles/build37.fa.bz2\n"
      + "##contig=<ID=1,length=249250621,assembly=B37,md5=1b22b98cdeb4a9304cb5d48026a85128,species=\"Homo sapiens\">\n"
      + "##contig=<ID=2,length=243199373,assembly=B37,md5=a0d9851da00400dec1098a9255ac712e,species=\"Homo sapiens\">\n"
      + "##contig=<ID=3,length=198022430,assembly=B37,md5=641e4338fa8d52a5b781bd2a2c08d3c3,species=\"Homo sapiens\">\n"
      + "##contig=<ID=4,length=191154276,assembly=B37,md5=23dccd106897542ad87d2765d28a19a1,species=\"Homo sapiens\">\n"
      + "##contig=<ID=5,length=180915260,assembly=B37,md5=0740173db9ffd264d728f32784845cd7,species=\"Homo sapiens\">\n"
      + "##contig=<ID=6,length=171115067,assembly=B37,md5=1d3a93a248d92a729ee764823acbbc6b,species=\"Homo sapiens\">\n"
      + "##contig=<ID=7,length=159138663,assembly=B37,md5=618366e953d6aaad97dbe4777c29375e,species=\"Homo sapiens\">\n"
      + "##contig=<ID=8,length=146364022,assembly=B37,md5=96f514a9929e410c6651697bded59aec,species=\"Homo sapiens\">\n"
      + "##contig=<ID=9,length=141213431,assembly=B37,md5=3e273117f15e0a400f01055d9f393768,species=\"Homo sapiens\">\n"
      + "##contig=<ID=10,length=135534747,assembly=B37,md5=988c28e000e84c26d552359af1ea2e1d,species=\"Homo sapiens\">\n"
      + "##contig=<ID=11,length=135006516,assembly=B37,md5=98c59049a2df285c76ffb1c6db8f8b96,species=\"Homo sapiens\">\n"
      + "##contig=<ID=12,length=133851895,assembly=B37,md5=51851ac0e1a115847ad36449b0015864,species=\"Homo sapiens\">\n"
      + "##contig=<ID=13,length=115169878,assembly=B37,md5=283f8d7892baa81b510a015719ca7b0b,species=\"Homo sapiens\">\n"
      + "##contig=<ID=14,length=107349540,assembly=B37,md5=98f3cae32b2a2e9524bc19813927542e,species=\"Homo sapiens\">\n"
      + "##contig=<ID=15,length=102531392,assembly=B37,md5=e5645a794a8238215b2cd77acb95a078,species=\"Homo sapiens\">\n"
      + "##contig=<ID=16,length=90354753,assembly=B37,md5=fc9b1a7b42b97a864f56b348b06095e6,species=\"Homo sapiens\">\n"
      + "##contig=<ID=17,length=81195210,assembly=B37,md5=351f64d4f4f9ddd45b35336ad97aa6de,species=\"Homo sapiens\">\n"
      + "##contig=<ID=18,length=78077248,assembly=B37,md5=b15d4b2d29dde9d3e4f93d1d0f2cbc9c,species=\"Homo sapiens\">\n"
      + "##contig=<ID=19,length=59128983,assembly=B37,md5=1aacd71f30db8e561810913e0b72636d,species=\"Homo sapiens\">\n"
      + "##contig=<ID=20,length=63025520,assembly=B37,md5=0dec9660ec1efaaf33281c0d5ea2560f,species=\"Homo sapiens\">\n"
      + "##contig=<ID=21,length=48129895,assembly=B37,md5=2979a6085bfe28e3ad6f552f361ed74d,species=\"Homo sapiens\">\n"
      + "##contig=<ID=22,length=51304566,assembly=B37,md5=a718acaa6135fdca8357d5bfe94211dd,species=\"Homo sapiens\">\n"
      + "##contig=<ID=X,length=155270560,assembly=B37,md5=7e0e2e580297b7764e31dbc80c2540dd,species=\"Homo sapiens\">\n"
      + "##contig=<ID=Y,length=59373566,assembly=B37,md5=1e86411d73e6f00a10590f976be01623,species=\"Homo sapiens\">\n"
      + "##contig=<ID=M,length=16569,assembly=B37,md5=c68f52674c9fb33aef52dcf399755519,species=\"Homo sapiens\">\n"
      + "##ALT=<ID=CGA_NOCALL,Description=\"No-called record\">\n"
      + "##ALT=<ID=CGA_CNVWIN,Description=\"Copy number analysis window\">\n"
      + "##ALT=<ID=INS:ME:ALU,Description=\"Insertion of ALU element\">\n"
      + "##ALT=<ID=INS:ME:L1,Description=\"Insertion of L1 element\">\n"
      + "##ALT=<ID=INS:ME:SVA,Description=\"Insertion of SVA element\">\n"
      + "##ALT=<ID=INS:ME:MER,Description=\"Insertion of MER element\">\n"
      + "##ALT=<ID=INS:ME:LTR,Description=\"Insertion of LTR element\">\n"
      + "##ALT=<ID=INS:ME:PolyA,Description=\"Insertion of PolyA element\">\n"
      + "##ALT=<ID=INS:ME:HERV,Description=\"Insertion of HERV element\">\n"
      + "##FILTER=<ID=VQLOW,Description=\"Call is homozygous and the varScoreVAF is less than 20dB, or the call is not homozygous and the varScoreVAF is less than 40dB\">\n"
      + "##FILTER=<ID=SQLOW,Description=\"Somatic variant has somaticScore < -10\">\n"
      + "##FILTER=<ID=FET30,Description=\"Fisher somatic score < 30\">\n"
      + "##FILTER=<ID=AMBIGUOUS,Description=\"Read evidence does not strongly distinguish multiple non-reference candidate alleles\">\n"
      + "##FILTER=<ID=URR,Description=\"Too close to an underrepresented repeat\">\n"
      + "##FILTER=<ID=MPCBT,Description=\"Mate pair count below 10\">\n"
      + "##FILTER=<ID=SHORT,Description=\"Junction side length below 70\">\n"
      + "##FILTER=<ID=TSNR,Description=\"Transition sequence not resolved\">\n"
      + "##FILTER=<ID=INTERBL,Description=\"Interchromosomal junction in baseline\">\n"
      + "##FILTER=<ID=sns75,Description=\"Sensitivity to known MEI calls in range (.75,.95] i.e. medium FDR\">\n"
      + "##FILTER=<ID=sns95,Description=\"Sensitivity to known MEI calls in range (.95,1.00] i.e. high to very high FDR\">\n"
      + "##INFO=<ID=NS,Number=1,Type=Integer,Description=\"Number of Samples With Data\">\n"
      + "##INFO=<ID=AN,Number=1,Type=Integer,Description=\"Total number of alleles in called genotypes\">\n"
      + "##INFO=<ID=AC,Number=A,Type=Integer,Description=\"Allele count in genotypes, for each ALT allele\">\n"
      + "##INFO=<ID=CGA_XR,Number=A,Type=String,Description=\"Per-ALT external database reference (dbSNP, COSMIC, etc)\">\n"
      + "##INFO=<ID=AF,Number=A,Type=String,Description=\"Allele frequency, or &-separated frequencies for complex variants (in latter, '?' designates unknown parts)\">\n"
      + "##INFO=<ID=CGA_FI,Number=A,Type=String,Description=\"Functional impact annotation\">\n"
      + "##INFO=<ID=CGA_PFAM,Number=.,Type=String,Description=\"PFAM Domain\">\n"
      + "##INFO=<ID=CGA_MIRB,Number=.,Type=String,Description=\"miRBaseId\">\n"
      + "##INFO=<ID=CGA_RPT,Number=.,Type=String,Description=\"repeatMasker overlap information\">\n"
      + "##INFO=<ID=CGA_SDO,Number=1,Type=Integer,Description=\"Number of distinct segmental duplications that overlap this locus\">\n"
      + "##INFO=<ID=END,Number=1,Type=Integer,Description=\"End position of the variant described in this record\">\n"
      + "##INFO=<ID=CGA_WINEND,Number=1,Type=Integer,Description=\"End of coverage window\">\n"
      + "##INFO=<ID=CGA_BF,Number=1,Type=Float,Description=\"Frequency in baseline\">\n"
      + "##INFO=<ID=CGA_MEDEL,Number=4,Type=String,Description=\"Consistent with deletion of mobile element; type,chromosome,start,end\">\n"
      + "##INFO=<ID=MATEID,Number=1,Type=String,Description=\"ID of mate breakend\">\n"
      + "##INFO=<ID=SVTYPE,Number=1,Type=String,Description=\"Type of structural variant\">\n"
      + "##INFO=<ID=CGA_BNDG,Number=A,Type=String,Description=\"Transcript name and strand of genes containing breakend\">\n"
      + "##INFO=<ID=CGA_BNDGO,Number=A,Type=String,Description=\"Transcript name and strand of genes containing mate breakend\">\n"
      + "##INFO=<ID=CIPOS,Number=2,Type=Integer,Description=\"Confidence interval around POS for imprecise variants\">\n"
      + "##INFO=<ID=IMPRECISE,Number=0,Type=Flag,Description=\"Imprecise structural variation\">\n"
      + "##INFO=<ID=MEINFO,Number=4,Type=String,Description=\"Mobile element info of the form NAME,START,END,POLARITY\">\n"
      + "##INFO=<ID=SVLEN,Number=.,Type=Integer,Description=\"Difference in length between REF and ALT alleles\">\n"
      + "##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">\n"
      + "##FORMAT=<ID=PS,Number=1,Type=Integer,Description=\"Phase Set\">\n"
      + "##FORMAT=<ID=SS,Number=1,Type=String,Description=\"Somatic Status: Germline, Somatic, LOH, or . (Unknown)\">\n"
      + "##FORMAT=<ID=FT,Number=1,Type=String,Description=\"Genotype filters\">\n"
      + "##FORMAT=<ID=CGA_ALTCALLS,Number=2,Type=String,Description=\"Alternative call sequences and scores\">\n"
      + "##FORMAT=<ID=GQ,Number=1,Type=Integer,Description=\"Genotype Quality\">\n"
      + "##FORMAT=<ID=HQ,Number=2,Type=Integer,Description=\"Haplotype Quality\">\n"
      + "##FORMAT=<ID=EHQ,Number=2,Type=Integer,Description=\"Haplotype Quality, Equal Allele Fraction Assumption\">\n"
      + "##FORMAT=<ID=GL,Number=.,Type=Integer,Description=\"Genotype Likelihood\">\n"
      + "##FORMAT=<ID=DP,Number=1,Type=Integer,Description=\"Total Read Depth\">\n"
      + "##FORMAT=<ID=AD,Number=2,Type=Integer,Description=\"Allelic depths (number of reads in each observed allele)\">\n"
      + "##FORMAT=<ID=CGA_RDP,Number=1,Type=Integer,Description=\"Number of reads observed supporting the reference allele\">\n"
      + "##FORMAT=<ID=CGA_GP,Number=1,Type=Float,Description=\"Depth of coverage for 2k window GC normalized to mean\">\n"
      + "##FORMAT=<ID=CGA_NP,Number=1,Type=Float,Description=\"Coverage for 2k window, GC-corrected and normalized relative to copy-number-corrected multi-sample baseline\">\n"
      + "##FORMAT=<ID=CGA_CL,Number=1,Type=Float,Description=\"Nondiploid-model called level\">\n"
      + "##FORMAT=<ID=CGA_LS,Number=1,Type=Integer,Description=\"Nondiploid-model called level score\">\n"
      + "##FORMAT=<ID=CGA_CP,Number=1,Type=Integer,Description=\"Diploid-model called ploidy\">\n"
      + "##FORMAT=<ID=CGA_PS,Number=1,Type=Integer,Description=\"Diploid-model called ploidy score\">\n"
      + "##FORMAT=<ID=CGA_CT,Number=1,Type=String,Description=\"Diploid-model CNV type\">\n"
      + "##FORMAT=<ID=CGA_TS,Number=1,Type=Integer,Description=\"Diploid-model CNV type score\">\n"
      + "##FORMAT=<ID=CGA_BNDMPC,Number=1,Type=Integer,Description=\"Mate pair count supporting breakend\">\n"
      + "##FORMAT=<ID=CGA_BNDPOS,Number=1,Type=Integer,Description=\"Breakend position\">\n"
      + "##FORMAT=<ID=CGA_BNDDEF,Number=1,Type=String,Description=\"Breakend definition\">\n"
      + "##FORMAT=<ID=CGA_BNDP,Number=1,Type=String,Description=\"Precision of breakend\">\n"
      + "##FORMAT=<ID=CGA_IS,Number=1,Type=Float,Description=\"MEI InsertionScore: confidence in occurrence of an insertion\">\n"
      + "##FORMAT=<ID=CGA_IDC,Number=1,Type=Float,Description=\"MEI InsertionDnbCount: count of paired ends supporting insertion\">\n"
      + "##FORMAT=<ID=CGA_IDCL,Number=1,Type=Float,Description=\"MEI InsertionLeftDnbCount: count of paired ends supporting insertion on 5' end of insertion point\">\n"
      + "##FORMAT=<ID=CGA_IDCR,Number=1,Type=Float,Description=\"MEI InsertionRightDnbCount: count of paired ends supporting insertion on 3' end of insertion point\">\n"
      + "##FORMAT=<ID=CGA_RDC,Number=1,Type=Integer,Description=\"MEI ReferenceDnbCount: count of paired ends supporting reference allele\">\n"
      + "##FORMAT=<ID=CGA_NBET,Number=1,Type=String,Description=\"MEI NextBestElementType: (sub)type of second-most-likely inserted mobile element\">\n"
      + "##FORMAT=<ID=CGA_ETS,Number=1,Type=Float,Description=\"MEI ElementTypeScore: confidence that insertion is of type indicated by CGA_ET/ElementType\">\n"
      + "##FORMAT=<ID=CGA_KES,Number=1,Type=Float,Description=\"MEI KnownEventSensitivityForInsertionScore: fraction of known MEI insertion polymorphisms called for this sample with CGA_IS at least as high as for the current call\">\n";

  /**
   * Use they key as part of the path for the final output file.
   */
  @Override
      protected String generateFileNameForKeyValue(K key, V value, String leaf) {
    return new Path(key.toString(), leaf).toString();
  }

  protected static class LineRecordWriter<K, V>
      implements RecordWriter<K, V> {
    private static final String utf8 = "UTF-8";
    private static final byte[] newline;
    static {
      try {
        newline = "\n".getBytes(utf8);
      } catch (UnsupportedEncodingException uee) {
        throw new IllegalArgumentException("can't find " + utf8 + " encoding");
      }
    }

    protected DataOutputStream out;
    private final byte[] keyValueSeparator;

    public LineRecordWriter(DataOutputStream out, String keyValueSeparator) {
      this.out = out;
      try {
        this.keyValueSeparator = keyValueSeparator.getBytes(utf8);
      } catch (UnsupportedEncodingException uee) {
        throw new IllegalArgumentException("can't find " + utf8 + " encoding");
      }
    }

    public LineRecordWriter(DataOutputStream out) {
      this(out, "\t");
    }

    /**
     * Write the object to the byte stream, handling Text as a special
     * case.
     * @param o the object to print
     * @throws IOException if the write throws, we pass it on
     */
    private void writeObject(Object o) throws IOException {
      if (o instanceof Text) {
        Text to = (Text) o;
        out.write(to.getBytes(), 0, to.getLength());
      } else if (o instanceof BytesWritable) {
        BytesWritable bytes = (BytesWritable) o;
        out.write(bytes.getBytes(), 0, bytes.getLength());
      } else {
        out.write(o.toString().getBytes(utf8));
      }
    }

    public synchronized void write(K key, V value)
                                 throws IOException {

        boolean nullKey = key == null || key instanceof NullWritable;
        boolean nullValue = value == null || value instanceof NullWritable;
        if (nullKey || nullValue) {
          return;
        }
        if (0 == out.size()) {
          // This record will be written to a newly opened file.
          // Write the VCF header first.
          String header = DATASET_HEADER
              + "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\t"
              + "INFO\tFORMAT\t"
              + key.toString()
              + "\n";
          out.write(header.getBytes(), 0,
              header.getBytes().length);
        }
        writeObject(value);
        out.write(newline);
      }

    public synchronized void close(Reporter reporter) throws IOException {
        out.close();
      }
  }

  public RecordWriter<K, V> getBaseRecordWriter(FileSystem ignored,
      JobConf job,
      String name,
      Progressable progress)
      throws IOException {
    boolean isCompressed = getCompressOutput(job);
    String keyValueSeparator = job.get("mapred.textoutputformat.separator",
        "\t");
    if (!isCompressed) {
      Path file = FileOutputFormat.getTaskOutputPath(job, name);
      FileSystem fs = file.getFileSystem(job);
      FSDataOutputStream fileOut = fs.create(file, progress);
      return new LineRecordWriter<K, V>(fileOut, keyValueSeparator);
    } else {
      Class<? extends CompressionCodec> codecClass =
          getOutputCompressorClass(job, GzipCodec.class);
      // create the named codec
      CompressionCodec codec = ReflectionUtils.newInstance(codecClass, job);
      // build the filename including the extension
      Path file =
          FileOutputFormat.getTaskOutputPath(job,
              name + codec.getDefaultExtension());
      FileSystem fs = file.getFileSystem(job);
      FSDataOutputStream fileOut = fs.create(file, progress);
      return new LineRecordWriter<K, V>(new DataOutputStream
          (codec.createOutputStream(fileOut)),
          keyValueSeparator);
    }
  }
}